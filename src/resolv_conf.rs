use anyhow::{Context, Result};
use log::{info, warn};
use std::fs;
use std::io::Write;
use std::net::IpAddr;
use std::path::Path;

pub struct ResolvConfManager {
    path: String,
}

impl ResolvConfManager {
    pub fn new(path: String) -> Self {
        Self { path }
    }

    /// Update /etc/resolv.conf with the selected DNS servers
    pub fn update_dns_servers(&self, dns_servers: &[IpAddr]) -> Result<()> {
        if dns_servers.is_empty() {
            anyhow::bail!("No DNS servers provided for update");
        }

        info!(
            "Updating {} with {} DNS servers",
            self.path,
            dns_servers.len()
        );

        // Create backup of current resolv.conf
        self.backup_current()?;

        // Generate new content
        let content = self.generate_resolv_conf(dns_servers);

        // Write to resolv.conf
        self.write_resolv_conf(&content)?;

        info!(
            "Successfully updated {} with DNS servers: {:?}",
            self.path, dns_servers
        );

        Ok(())
    }

    fn backup_current(&self) -> Result<()> {
        let backup_path = format!("{}.backup", self.path);

        if Path::new(&self.path).exists() {
            fs::copy(&self.path, &backup_path)
                .with_context(|| format!("Failed to backup {} to {}", self.path, backup_path))?;
            info!("Created backup at {}", backup_path);
        }

        Ok(())
    }

    fn generate_resolv_conf(&self, dns_servers: &[IpAddr]) -> String {
        let mut content = String::new();

        content.push_str("# Generated by autodns\n");
        content.push_str(&format!(
            "# Updated at: {}\n",
            chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
        ));
        content.push_str("#\n");
        content.push_str("# This file is automatically managed by autodns.\n");
        content.push_str("# Manual changes will be overwritten.\n");
        content.push('\n');

        for dns in dns_servers {
            content.push_str(&format!("nameserver {}\n", dns));
        }

        content.push('\n');
        content.push_str("options timeout:2\n");
        content.push_str("options attempts:3\n");

        content
    }

    fn write_resolv_conf(&self, content: &str) -> Result<()> {
        // Try to write to a temporary file first
        let temp_path = format!("{}.tmp", self.path);

        {
            let mut file = fs::File::create(&temp_path)
                .with_context(|| format!("Failed to create temporary file {}", temp_path))?;

            file.write_all(content.as_bytes())
                .context("Failed to write to temporary file")?;

            file.sync_all().context("Failed to sync temporary file")?;
        }

        // Move temporary file to actual location
        fs::rename(&temp_path, &self.path)
            .with_context(|| format!("Failed to move temporary file to {}", self.path))?;

        Ok(())
    }

    /// Check if we have permission to write to resolv.conf
    pub fn check_permissions(&self) -> Result<()> {
        let path = Path::new(&self.path);

        // Check if path is a symlink (common with systemd-resolved)
        if path.is_symlink() {
            let target = fs::read_link(path)
                .with_context(|| format!("Failed to read symlink target for {}", self.path))?;

            warn!("{} is a symlink to {:?}", self.path, target);

            // Check if it's systemd-resolved
            let target_str = target.to_string_lossy();
            if target_str.contains("systemd/resolve") || target_str.contains("run/systemd/resolve") {
                warn!("⚠ DETECTED: Your system uses systemd-resolved");
                warn!("⚠ systemd-resolved may overwrite this file");
                warn!("⚠ Consider:");
                warn!("   1. Disabling systemd-resolved: sudo systemctl disable systemd-resolved");
                warn!("   2. Or configure Autodns to use a different path in config.yaml");
                warn!("   3. Or configure systemd-resolved to use Autodns-managed DNS");
            }
        }

        // Check if file exists and we can read it
        if path.exists() {
            fs::read_to_string(path)
                .with_context(|| format!("Cannot read {}. Check file permissions.", self.path))?;
        } else {
            warn!("{} does not exist yet. Will be created.", self.path);
        }

        // Check if we can write to the target location
        // Try the complete write operation in a test mode
        match self.test_write_capability() {
            Ok(_) => {
                info!("✓ Permission check passed for {}", self.path);
                Ok(())
            }
            Err(e) => {
                anyhow::bail!(
                    "✗ No write permission for {}. This program needs to run with sudo/root privileges.\nError: {}",
                    self.path,
                    e
                )
            }
        }
    }

    /// Test if we can perform the complete write operation (create temp + move)
    fn test_write_capability(&self) -> Result<()> {
        let path = Path::new(&self.path);
        let parent = path.parent()
            .with_context(|| format!("Cannot determine parent directory for {}", self.path))?;

        // Test 1: Check if parent directory is writable
        let test_temp_file = parent.join(".autodns-test.tmp");

        // Try to create a temporary test file
        {
            let mut file = fs::File::create(&test_temp_file)
                .with_context(|| format!("Cannot create temporary files in {}", parent.display()))?;

            file.write_all(b"# autodns permission test\nnameserver 1.1.1.1\n")
                .context("Cannot write to temporary file")?;

            file.sync_all()
                .context("Cannot sync temporary file")?;
        }

        // Test 2: Try to move the temp file to target (or a test target)
        let test_target = if path.exists() {
            // If target exists, test by moving to a different test location
            parent.join(".autodns-test.conf")
        } else {
            // If target doesn't exist, we can test directly
            path.to_path_buf()
        };

        fs::rename(&test_temp_file, &test_target)
            .with_context(|| {
                format!(
                    "Cannot move files to {}. This usually requires root/sudo privileges.",
                    path.display()
                )
            })?;

        // Clean up test files
        let _ = fs::remove_file(&test_target);
        let _ = fs::remove_file(&test_temp_file);

        Ok(())
    }

    /// Read current DNS servers from resolv.conf
    #[allow(dead_code)]
    pub fn read_current_servers(&self) -> Result<Vec<IpAddr>> {
        if !Path::new(&self.path).exists() {
            warn!("{} does not exist", self.path);
            return Ok(Vec::new());
        }

        let content = fs::read_to_string(&self.path)
            .with_context(|| format!("Failed to read {}", self.path))?;

        let servers: Vec<IpAddr> = content
            .lines()
            .filter(|line| line.trim().starts_with("nameserver"))
            .filter_map(|line| {
                line.split_whitespace()
                    .nth(1)
                    .and_then(|ip| ip.parse::<IpAddr>().ok())
            })
            .collect();

        Ok(servers)
    }
}

// Add chrono dependency for timestamps
impl Default for ResolvConfManager {
    fn default() -> Self {
        Self::new("/etc/resolv.conf".to_string())
    }
}
