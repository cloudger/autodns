use std::fs;
use std::io::Write;
use std::net::IpAddr;
use std::path::Path;
use anyhow::{Context, Result};
use log::{info, warn};

pub struct ResolvConfManager {
    path: String,
}

impl ResolvConfManager {
    pub fn new(path: String) -> Self {
        Self { path }
    }

    /// Update /etc/resolv.conf with the selected DNS servers
    pub fn update_dns_servers(&self, dns_servers: &[IpAddr]) -> Result<()> {
        if dns_servers.is_empty() {
            anyhow::bail!("No DNS servers provided for update");
        }

        info!("Updating {} with {} DNS servers", self.path, dns_servers.len());

        // Create backup of current resolv.conf
        self.backup_current()?;

        // Generate new content
        let content = self.generate_resolv_conf(dns_servers);

        // Write to resolv.conf
        self.write_resolv_conf(&content)?;

        info!("Successfully updated {} with DNS servers: {:?}", self.path, dns_servers);

        Ok(())
    }

    fn backup_current(&self) -> Result<()> {
        let backup_path = format!("{}.backup", self.path);

        if Path::new(&self.path).exists() {
            fs::copy(&self.path, &backup_path)
                .with_context(|| format!("Failed to backup {} to {}", self.path, backup_path))?;
            info!("Created backup at {}", backup_path);
        }

        Ok(())
    }

    fn generate_resolv_conf(&self, dns_servers: &[IpAddr]) -> String {
        let mut content = String::new();

        content.push_str("# Generated by dns-manager\n");
        content.push_str(&format!("# Updated at: {}\n", chrono::Local::now().format("%Y-%m-%d %H:%M:%S")));
        content.push_str("#\n");
        content.push_str("# This file is automatically managed by dns-manager.\n");
        content.push_str("# Manual changes will be overwritten.\n");
        content.push('\n');

        for dns in dns_servers {
            content.push_str(&format!("nameserver {}\n", dns));
        }

        content.push('\n');
        content.push_str("options timeout:2\n");
        content.push_str("options attempts:3\n");

        content
    }

    fn write_resolv_conf(&self, content: &str) -> Result<()> {
        // Try to write to a temporary file first
        let temp_path = format!("{}.tmp", self.path);

        {
            let mut file = fs::File::create(&temp_path)
                .with_context(|| format!("Failed to create temporary file {}", temp_path))?;

            file.write_all(content.as_bytes())
                .context("Failed to write to temporary file")?;

            file.sync_all()
                .context("Failed to sync temporary file")?;
        }

        // Move temporary file to actual location
        fs::rename(&temp_path, &self.path)
            .with_context(|| format!("Failed to move temporary file to {}", self.path))?;

        Ok(())
    }

    /// Check if we have permission to write to resolv.conf
    pub fn check_permissions(&self) -> Result<()> {
        if !self.can_write() {
            anyhow::bail!(
                "No write permission for {}. This program needs to run with sudo/root privileges.",
                self.path
            );
        }
        Ok(())
    }

    fn can_write(&self) -> bool {
        // Check if parent directory is writable
        let path = Path::new(&self.path);

        if let Some(parent) = path.parent() {
            // Try to create a test file
            let test_file = parent.join(".dns-manager-test");
            if let Ok(mut file) = fs::File::create(&test_file) {
                let _ = file.write_all(b"test");
                let _ = fs::remove_file(&test_file);
                return true;
            }
        }

        false
    }

    /// Read current DNS servers from resolv.conf
    pub fn read_current_servers(&self) -> Result<Vec<IpAddr>> {
        if !Path::new(&self.path).exists() {
            warn!("{} does not exist", self.path);
            return Ok(Vec::new());
        }

        let content = fs::read_to_string(&self.path)
            .with_context(|| format!("Failed to read {}", self.path))?;

        let servers: Vec<IpAddr> = content
            .lines()
            .filter(|line| line.trim().starts_with("nameserver"))
            .filter_map(|line| {
                line.split_whitespace()
                    .nth(1)
                    .and_then(|ip| ip.parse::<IpAddr>().ok())
            })
            .collect();

        Ok(servers)
    }
}

// Add chrono dependency for timestamps
impl Default for ResolvConfManager {
    fn default() -> Self {
        Self::new("/etc/resolv.conf".to_string())
    }
}
